\documentclass[leqno,10pt]{article}

% when these lines were placed too far below here,
% makeindex mysteriously produced no entries
\usepackage{makeidx} 
\makeindex

\usepackage{boxedminipage}

%\bibliographystyle{apsrev}
%\bibliographystyle{apsrmp} % makes a little garbage in html not too bad
%\bibliographystyle{plain}
%\bibliographystyle{plainnat}

%\bibliographystyle{plain_ep_doi_ht}
\bibliographystyle{plain_ep_doi_hr}

%\bibliographystyle{naturemag} % eprints, pretty, no links
%\bibliographystyle{naturemag_ep_doi_hr} % eprints, pretty, no links
%\bibliographystyle{plainurl} % no eprint, links to aps
%\bibliographystyle{plainhtml} % kinda garbage from latex2html

\usepackage{html}

%% This is to get the bibliography to work
\html{ \renewcommand{\href}[2]{\url{#1}} } % putting #2 in looks like garbage

%%%%%%%%%%%%
% bug: sections only bold function names in TOC if
% other parts in title also have math in them.
% kludge: end each section title with $.$
%%%%%%%%%%%%

% Make boxed minipage  wider for html version
\html{ \newcommand{\bbm}{\vspace{5pt}\par\noindent\begin{boxedminipage}{2.0\linewidth}} }
\latex{ \newcommand{\bbm}{\vspace{5pt}\par\noindent\begin{boxedminipage}{1.05\linewidth}} }
%%\latex{ \newcommand{\bbm}{\vspace{5pt}\par\noindent\begin{boxedminipage}{1.5\linewidth}} }

%% We do not include the html maxima manual  
%% links to the maxima manual. this also gives the top directory
%%\def\maxdocdir{/usr/share/doc/maxima-doc/html/}
%T%\def\maxdocdir{../maxima_html/}
\def\maxdocdir{http://maxima.sourceforge.net/docs/manual/en/}
\newcommand{\maxlink}[1]{{\maxdocdir}#1}
\html{\newcommand{\maxman}[2]{\hlink{#1}{\maxlink{#2}}}}
% umaxman prints word in bold with dagger. makes index entry. makes link to manual
\html{\newcommand{\umaxman}[2]{\maxman{{\bf #1}}{#2}\maxcom\index{#1@{\bf #1}}}}
% same, no dagger, no bold
\newcommand{\imaxman}[2]{\maxman{#1}{#2}\index{#1}}
\latex{ \newcommand{\maxman}[2]{#1}}
\latex{\newcommand{\umaxman}[2]{\fs{#1}\index{#1@{\bf #1}}}}
% bizarre bugs if I put two newcommands in one \latex or \html command

\newcommand{\hlink}[2]{\htmladdnormallink{#1}{#2}}

%% These are used only for generating html I think.
% \input{man_index.tex}
% \input{man_contents.tex}

\usepackage{graphicx}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = red %Colour of citations
}

%% following is added by imaxima output
\usepackage{verbatim}
\usepackage[cmbase]{flexisym}
\usepackage{bbold}

% bbold above conflicts with amssymb \usepackage{amssymb}
%\usepackage{amssymb} this breaks bbold numeral

\usepackage{breqn}
\setkeys{breqn}{compact}

\def\supertiny{ \font\supertinyfont = cmr6 at 4pt \relax
\supertinyfont}

\newcommand{\ebm}{\end{boxedminipage}\vspace{5pt}\par\noindent}
\setlength{\fboxrule}{0.1pt} 
\setlength{\fboxsep}{10pt}

\setlength{\textwidth}{180mm}
\setlength{\oddsidemargin}{15mm}
\addtolength{\oddsidemargin}{-1in}
\setlength{\evensidemargin}{15mm}
\addtolength{\evensidemargin}{-1in}

\newcommand{\ifrac}[2]{\frac{#1}{#2}}
\newcommand{\ifracd}[2]{\frac{#1}{#2}}
\newcommand{\ifracn}[2]{\frac{#1}{#2}}
\newcommand{\isubscript}[2]{{#1}_{#2}}
\newcommand{\iexpt}[2]{{#1}^{#2}}
\newcommand{\isqrt}[1]{\sqrt{#1}}
%% end lines added by imaxima output

\newcommand{\ket}[1]{{\lvert#1 \rangle}}
\newcommand{\bra}[1]{{\langle#1 \rvert}}
\newcommand{\bracket}[2]{{\langle#1|#2\rangle}}
\newcommand{\func}[2]{{\bf #1}($#2$)}
\newcommand{\marray}[2]{{\bf #1}[$#2$]}
\newcommand{\fs}[1]{{\bf #1}}

% refer to a function and add an index entry

% version with \bf makes html fail to bf on most/not all uses
\newcommand{\ifs}[1]{ {\bf #1} \index{#1@{\bf #1}}} % bold index entry plus bold in text
% version with textbf  makes html fail to bf on all uses
%\newcommand{\ifs}[1]{ \textbf{#1} \index{#1@{\bf #1}}} % bold index entry plus bold in text

\newcommand{\ient}[1]{{#1}\index{#1}} % index entry plus text
\newcommand{\ibd}[1]{\index{#1@{\bf #1}}} % bold index entry
% following doesnt work because tex sucks
\newcommand{\iit}[1]{\index{#1@{\it #1}}} % italic index entry
% package or software proper name, with an index entry
\newcommand{\ipname}[1]{{\it #1}\index{#1@{\it #1}}}
\newcommand{\pname}[1]{{\it #1}} % software name 
\newcommand{\imarray}[2]{\marray{#1}{#2}\index{#1@{\marray{#1}{#2}}}} % \marray with index entry
\newcommand{\ifunc}[2]{\func{#1}{#2}\index{#1@\func{#1}{#2}}} % \func with index entry
\newcommand{\qinf}{\textit{qinf} } % the name of this package
\newcommand{\qinfp}{{\textit{qinf}}} % use at end of sentece for period

\newcommand{\farg}[1]{{\it #1}} % an argument

\newcommand{\maximalink}{\htmladdnormallink{ \pname{Maxima} }{http://maxima.sourceforge.net/}}
\newcommand{\maximanolink}{\pname{Maxima} }

\newcommand{\maxcom}{\textsuperscript{$\dagger$}}

%\latex{\mref}[1]{}
%\html{\mref}[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BEGIN DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Reproducible research using the \qinf quantum information package
  for  the \pname{Maxima} CAS
  }

\author{G. John Lapeyre, Jr.}

\maketitle

\tableofcontents

\htmlrule
\section{Introduction}

This document describes how to do reproducible research in quantum
information theory using the \textit{qinf} package for the \maximalink computer algebra
system. We begin with a tutorial and description of \textit{Maxima} and \textit{qinf}.
In the last section, we check a calculation in Ref.~\cite{perseguers:022308},
\textit{Entanglement distribution in pure-state quantum networks}. We
find that the calculation is correct, but identify a copying error.

This quantum information package for the \maximalink computer algebra
system allows the manipulation of objects--- operators,
vectors, tensors, {\it etc.}  that appear in the theory of quantum
information and of quantum entanglement.  More precisely, these
objects are typically represented in this package as row and column
vectors and matrices, whose entries may be explicit numbers (of
various classes) or algebraic expressions. This software occupies a
niche distinct from high performance numerical linear algebra software
as well as software such as the \maximanolink tensor packages that
manipulate abstract mathematical objects. The package is intended for
research and teaching in the theory of entanglement and quantum
information and related fields.

This document describes the functions and data in the package and how
to use them with \maximanolink, assuming that you do not know much about
\maximanolink, but do know quantum information theory. However, most of
the examples here are elementary. Popular introductory sources on
quantum information include the book by Nielsen and
Chuang\cite{Nielsen}, the notes (a book) by Preskill\cite{Preskill},
and the notes and book by Mermin\cite{Mermin}. There are many other
sources available online as well.

Examples of the facilities of the
package are
\begin{itemize}
%  \begin{item}
  \item    Methods for constructing pure and mixed states and operators.
%  \end{item}
%  \begin{item}
   \item  Methods for executing standard operations found in
    computational linear algebra as well as the tensor
    product, partial trace, etc.
%  \end{item}
%  \begin{item}
   \item Functions to compute useful quantities such as entropy and purity.
%  \end{item}
\end{itemize}

We begin with a very brief introduction to \maximalink
emphasizing features that are important for \qinfp.
This is followed by a series of small sections introducing functions with
examples. The examples consist mostly of testing equations.
Identities and textbook exercises are presented, in part because they
are the natural calculations to include in the test suite from which
they are taken.

Finally, we check calculations and results in a published paper. In this
sense, the package can give results on simple abstract statements: If
1) generic instances of objects are generated, and 2) a
representation-invariant statement is formulated, and 3) the
subexpressions are successfully coerced into some canonical form, then
defects in the statement can sometimes be detected if the statement is
not true.

Some suggestions and things to be aware of in the following sections.
\begin{itemize}
\item You probably need to read at least a ten minute
  \pname{Maxima} tutorial before or in conjunction with
  reading this document. There are several listed at the
  \maximalink website, and others that a search engine can
  find. If you are too impatient there is a very brief
  introduction to \maximanolink below. The best source for
  most questions is the \maxman{\pname{Maxima} manual}{maxima.html}.
\begin{comment}
  \begin{item}
    Functions and features that are part of the standard \maximanolink distribution,
    rather than part of the quantum information
    package are marked, where not obvious, with the dagger superscript--- \maxcom.
  \end{item}
\end{comment}
   \item
    There are several user interfaces to \maximanolink. All the
    examples here are generated using the 
    \htmladdnormallink{\pname{imaxima}}{http://members3.jcom.home.ne.jp/imaxima/Site/Welcome.html}
    \iit{imaxima} package
    for the \ipname{emacs} editor/environment, but the results are
    similar to other graphical frontends to \maximanolink. Other popular graphical
    frontends are \hlink{\pname{wxmaxima}}{http://wxmaxima.sourceforge.net}\iit{wxmaxima},
    and \hlink{\pname{texmacs}}{http://www.texmacs.org/}.\iit{texmacs}
   \item
    Most functions currently work only with qubits, others for variable number of
    states.
\end{itemize}

\subsection{Acknowledgments}

Some of the ideas used in \pname{qinf} are inspired by the package 
\html{\htmladdnormallink{\ipname{qdensity}}{http://www.pitt.edu/~tabakin/QDENSITY/}}
\begin{latexonly}
\ipname{qdensity} at \url{http://www.pitt.edu/~tabakin/QDENSITY/}
\end{latexonly}
written for a proprietary symbolic algebra system. None of
the code in qdensity has been borrowed for the present project,
however. Advice on \pname{Maxima}
programming was provided by, among others, Robert Dodier,
Richard Fateman, Stavros Macrakis, and Barton Willis.

\htmlrule
\section{Representation of states and operators}
Kets are represented by $n \times 1$ matrices, bras by $1
\times n$ matrices.\index{kets!representation} The objects
are represented in the computational basis.  Bras and kets
representing the same states are related by the conjugate
transpose \index{conjugate transpose}
\index{hermitian conjugate}  function.
\umaxman{ctranspose}{\maximactranspose}
% can't get this to work
% there has to be a way to write the following with one argument and
% one macro instead of three arguments and four macros
%\maxman{\fs{ctranspose}}{\maximactranspose}\maxcom\ibd{ctranspose}
Density operators and operators on a Hilbert space of kets
are represented by matrices.
 There is no strong
typing. You are responsible for knowing that a particular
vector represents a state vector in a particular space.
Below, we often substitute ``the operator'' for
``the matrix representing the operator''.

The notation for
\index{matrix!multiplication} matrix multiplication in
\pname{Maxima} is a \maxman{dot}{\maximaDot} \index{dot product},
 e.g. \verb|A . B|.  If
$A$ is a $m\times n$ matrix and $B$ a $p\times q$ matrix, then 
\verb| A . B |  is a $n\times p$ matrix. Each of the following
products is a special case of matrix multiplication and 
is represented by a dot:  The inner
product\index{inner product} of quantum state vectors,
 e.g. $\bracket{a}{b}$; The
outer product \index{outer product} (dyad\index{dyad})
 of quantum state vectors, e.g. $\ket{a}\bra{b}$; The composition of
operators e.g. $AB$; The mapping of one vector to another by an
operator e.g. $\ket{a}= A\ket{b}$.
(Conjugation is also used in the case  of the inner and outer products.)  The remaining product, the
tensor product\index{tensor product}, becomes the 
Kronecker product\index{tensor product!matrix representation}
 in the matrix
representation of a finite dimensional Hilbert space. To
agree with standard terminology, we introduce the
\imaxman{infix}{\maximainfix}
operator \htmlref{\ifs{otimes}}{f:tensorproduct} and the function
\htmlref{\ifs{tensor\_product}}{f:tensorproduct}
that eventually call the \pname{Maxima} function
\umaxman{kronecker\_product}{\maximakroneckerUproduct}.  See the 
\maxman{section on matrices}{\maximaMatricesandLinearAlgebra} in the \pname{Maxima}
manual. Simple examples of using these operators are given in the following sections.

\htmlrule

\section{Using \pname{Maxima}. features important for \qinfp$.$}
The package is loaded \index{loading \qinf}
using the \maxman{load}{\maximaload}\maxcom function like this
\bbm\index{\ifs{load}}
\begin{verbatim}
(%i1) load("qinf.mac");
\end{verbatim}
\begin{dmath}[number={\%o1}]
 \verb|qinf.mac|\end{dmath}
\ebm
There are several tutorials and manuals available for
\pname{Maxima}. Here is a very brief one focused on aiding the
introduction to the \qinf package. 
\pname{Maxima} can use exact real and 
\maxman{complex numbers}{\maximaComplex} or the standard 
\maxman{floating point}{\maximaFloatingPoint}  approximations, or 
arbitrary precision floating point  numbers.  Numerical expressions are
\imaxman{simplified}{\maximasimplification} upon entry. Each input line must be terminated by
a semicolon (some interfaces do this automatically) or by a
dollar sign, which suppresses the output.
\bbm
\begin{verbatim}
(%i1) 1 + 1;
\end{verbatim}
\begin{dmath}[number={\%o1}]
  2\end{dmath} 
\ebm
\maxman{Assignment}{\maximacolon} is denoted by a colon \index{assignment} while
% fix below. := cant be used in macro. but perl can change them to
% 'colon' and 'equal'
\maxman{function definitions}{\maximacolonequal} are denoted by 
%\verb|:=|  broken by some package cant remember.
:=
\index{functions!user defined}
For example, \verb| a : b+c ;| evaluates \verb|b+c| and assigns the result to \verb|a|.
On the other hand \verb| a(x,y) := x^y ;| defines the function $a(x,y)$.
\bbm
\begin{verbatim}
(%i2) a : 2 * 2;
\end{verbatim}
\begin{dmath}[number={\%o2}]
 4\end{dmath}
\begin{verbatim}
(%i3) a;
\end{verbatim}
\begin{dmath}[number={\%o3}]
 4\end{dmath}
\begin{verbatim}
(%i4) b : expand( (x+y)^4 );
\end{verbatim}
\begin{dmath}[number={\%o4}]
 y^{4}+4\*x\*y^{3}+6\*x^{2}\*y^{2}+4\*x^{3}\*y+x^{4}\end{dmath}
\ebm
\index{suppressing output}
We suppress the output here with a dollar sign because it's big-- $51$ terms.
\ibd{expand}
\bbm
\begin{verbatim}
(%i5) b : expand( (x+y)^50 )$
(%i6) length(b);
\end{verbatim}
\begin{dmath}[number={\%o6}]
 51\end{dmath}
\ebm
Some exact numbers and  \maxman{floating point}{\maximaFloatingpointEvaluation} approximations.
\bbm
\begin{verbatim}
(%i7)  1  + sqrt(2);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 \isqrt{2}+1\end{dmath}
\index{floating point, conversion to}
\begin{verbatim}
(%i8)  1  + sqrt(2), float;
\end{verbatim}
\begin{dmath}[number={\%o8}]
 2.4142135623730949\end{dmath}
\ebm
\maxman{Defining}{\maximaFunctionDefinition} and using a function.
\index{functions!user defined}
\bbm
\begin{verbatim}
(%i9) f(x) := 3 * cos(x);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 f\left(x\right):=3\*\cos x\end{dmath}
\begin{verbatim}
(%i10) f(a);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 3\*\cos 4\end{dmath}
\begin{verbatim}
(%i11) f(0);
\end{verbatim}
\begin{dmath}[number={\%o11}]
 3\end{dmath}
\ebm
\index{complex numbers}
\maxman{Complex numbers}{maxima_6.html#SEC22}.
% \verb|%i|
\%i
 is the identifier for 
\index{imaginary unit $i$} $i=\sqrt{-1}$.
\bbm
\begin{verbatim}
(%i12) expand ( (1 + 2 * %i)^2 );
\end{verbatim}
\begin{dmath}[number={\%o12}]
 4\*i-3\end{dmath}
\ebm
Some special numbers are defined, such as 
%\verb|%pi|
\%pi
 \index{pi $\pi$}
and \index{$e$ base of natural log}
% \verb|%e|.
\%e.
\bbm
\begin{verbatim}
(%i13) cos(%pi/2);
\end{verbatim}
\begin{dmath}[number={\%o13}]
 0\end{dmath}
\begin{verbatim}
(%i14) %e^(%i * %pi/2);
\end{verbatim}
\begin{dmath}[number={\%o14}]
 i\end{dmath}
\ebm


\htmlrule
\section{Creating instances of states}
Here are some methods for creating instances of states, from scratch or
from other states. Although all operators  `create' states in this
sense, we omit most of them here, because they are better described as manipulating
states.
\subsection{\fs{ketz}, \fs{braz}, \fs{ketx}, \fs{brax},
  \fs{kety}, \fs{bray} --- multipartite eigenstate kets and bras of 
 $\sigma_x,\sigma_y,\sigma_z$ \label{f:ketz}}
\ibd{ketz}\ibd{ketx}\ibd{kety}\ibd{braz}\ibd{brax}\ibd{bray}
\index{states!creating a ket}
\index{kets!creating a ket|see{states}}
create normalized $n$-partite product states in the computational basis.
%\func{ketz}{i_1,\ldots,i_n} creates an eigenstate (ket) of $\sigma_z^{\otimes n}$
In all cases the indices are $0$ or $1$. The pair 
\func{ketz}{{i_1,\ldots,i_n}} and \func{braz}{{i_1,\ldots,i_n}} produce
eigenstates of $\sigma_z^{(1)} \otimes \cdots \otimes \sigma_z^{(n)}$,
with the index $i=0$ selecting the state with eigenvalue $1$ and
$i=1$ selecting the state with eigenvalue $-1$.
In other words the ket produced represents $\ket{i_1,i_2,\ldots,i_n}.$
Here is $\ket{1}$.
\bbm
\begin{verbatim}
(%i3) ketz(1)
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{0\cr 1\cr }\end{dmath}
\ebm
Here are $\bra{1}$ and $\bra{0}$.
\bbm
\begin{verbatim}
(%i4) braz(1)
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{0&\linebreak[0]1\cr }\end{dmath}
\ebm
\bbm
\begin{verbatim}
(%i5) braz(0)
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{1&\linebreak[0]0\cr }\end{dmath}
\ebm
Here are the states $\bra{00},\bra{11},$ and
$\alpha_0\bra{00} + \alpha_1\bra{11}$. (we show bras rather than
kets to conserve space)
\bbm
\begin{verbatim}
(%i6) braz(0,0)
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr }\end{dmath}
\begin{verbatim}
(%i7) braz(1,1)
\end{verbatim}
\begin{dmath}[number={\%o7}]
 \pmatrix{0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr }\end{dmath}
\begin{verbatim}
(%i8) alpha[1]*braz(1,1)+alpha[0]*braz(0,0)
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \pmatrix{\alpha_{0}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\alpha_{1}\cr }\end{dmath}
\ebm

The functions \ifs{ketx}, \ifs{brax}, \ifs{kety}, \ifs{bray} produce
eigenstates of $\sigma_x^{(1)} \otimes \cdots \otimes \sigma_x^{(n)}$,
or $\sigma_y^{(1)} \otimes \cdots \otimes \sigma_y^{(n)}$,
with, as before, the index $i=0$ selecting the state with eigenvalue $1$ and
$i=1$ selecting the state with eigenvalue $-1$.
Here are $\bra{x+}=(\bra{0}-\bra{1})/\sqrt(2)$ and
$\bra{x+}\otimes\bra{x-}\otimes\bra{x+}$.
\bbm
\begin{verbatim}
(%i9) brax(1)
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \pmatrix{\ifracd{1}{\isqrt{2}}&\linebreak[0]-\ifracd{1}{\isqrt{2}}\cr }\end{dmath}
\begin{verbatim}
(%i10) bray(1,0,1)
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]-\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}&\linebreak[0]-\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{1}{2\*\isqrt{2}}&\linebreak[0]\ifracd{i}{2\*\isqrt{2}}\cr }\end{dmath}
\ebm

\subsection{\fs{ket\_n}, \fs{bra\_n} ---  alternate form of \fs{ketz}, etc$.$}
\ibd{ket\_n}\ibd{bra\_n}
\func{ket\_n}{j,i_1,\ldots,i_m} and \func{bra\_n}{j,i_1,\ldots,i_m}
 are an alternate way to call \fs{ketx}, \fs{kety}, etc. The index $j\in(1,2,3)$
is mapped to $(x,y,z)$ and the appropriate function, e.g. \fs{ketx} is called with
the remaining arguments.

\subsection{\fs{proj} --- Density matrix representation of a pure state (projection operator)$.$}
\ibd{proj}
The projection operator \index{projection operator}
\index{density operator!of a pure state} (or equivalently, the density
matrix) corresponding to a state vector is generated via the
outer product, which is represented by the dot operator.  A
convenience function \func{proj}{ket} is also provided to
form a projection operator. The argument \farg{ket} can be either a bra
or a ket (i.e. column or row vector). (\ifs{proj} does not check that
\farg{ket} is normalized.) Below, we use the \pname{Maxima} function
\ifs{ctranspose} for the complex transpose.
Here is the outer product, or dyad\index{outer product!of state vectors}\index{dyad}
$\ket{x+}\bra{x+}$.
\bbm
\begin{verbatim}
(%i19) ketx(1) . brax(1);
\end{verbatim}
\begin{dmath}[number={\%o19}]
 \pmatrix{\frac{1}{2}&\linebreak[0]-\frac{1}{2}\cr -\frac{1}{2}&\linebreak[0]\frac{1}{2}\cr }\end{dmath}
\ebm
Compare this to the inner product\index{inner product!of state vectors}
 $\bracket{x+}{x+}$
\bbm
\begin{verbatim}
(%i20) brax(1) . ketx(1);
\end{verbatim}
\begin{dmath}[number={\%o20}]
 1\end{dmath}
\ebm
Here are different ways to make $\ket{000}\bra{000}$ and $\ket{101}\bra{101}$.
\bbm
\begin{verbatim}
(%i21) is ( ketz(0,0,0) . braz(0,0,0) =  ketz(0,0,0) . ctranspose(ketz(0,0,0)) );
\end{verbatim}
\begin{dmath}[number={\%o21}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i22) is ( ketz(1,0,1) . braz(1,0,1) =  proj(ketz(1,0,1)) );
\end{verbatim}
\begin{dmath}[number={\%o22}]
 \mathbf{true}\end{dmath}
\ebm
This example used the
\maxman{\func{is}{expr}}{\maximais}\maxcom\index{equality!testing for}
\ibd{is}  function which
tries to determine whether the predicate \farg{expr} is true or false.


There is also a function \ifs{tovect} that
is the inverse (up to a phase) of \ifs{proj}--- it returns the ket corresponding to a
projection operator. If the input matrix is not a projection operator,
the result is undefined.
\bbm
\begin{verbatim}
(%i17) is ( tovect( proj(schmidt_ket(alpha))) = schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o17}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\fs{otimes}, \fs{tensor\_product}, \fs{tensor\_power}
   --- Creating state vectors with the tensor product$.$ \label{f:tensorproduct}}
\ibd{otimes}\ibd{tensor\_product}\ibd{tensor\_power}
\index{tensor product} \index{tensor power}
The function \func{tensor\_product}{v_1,\ldots,v_n}, returns
$v_1\otimes v_2\cdots\otimes v_n$, where $v_i$ are vectors
or matrices. The \fs{otimes} operator is an `infix' operator
that is equivalent to the function \fs{tensor\_product}.
The function \func{tensor\_power}{op,n}, returns the $n$th
tensor power of the operator \verb|op|. 
Once again, we will employ the 
% here, we have to make a separate bold index entry with \ibd, otherwise the link is broken
\maxman{\fs{is}\maxcom}{\maximais}\ibd{is}
 function.
Keep in mind that, in this example, the expressions are not
analyzed abstractly, but rather vectors with integer
elements are generated and compared elementwise.  \bbm
\begin{verbatim}
(%i12) is (ketz(0,1) = ketz(0) otimes ketz(1))
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i13) is (ketz(0,1) = tensor_product(ketz(0),ketz(1)))
\end{verbatim}
\begin{dmath}[number={\%o13}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i14) is (ketx(0,1,0) otimes kety(1,0,1)
            = tensor_product(ketx(0),ketx(1),ketx(0),kety(1),kety(0),kety(1)))
\end{verbatim}
\begin{dmath}[number={\%o14}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\fs{schmidt\_ket} --- bipartite ket in Schmidt basis$.$}
\ibd{schmidt\_ket}
\func{schmidt\_ket}{a}creates a ket in the Schmidt form. \index{Schmidt basis} This is
equivalent to \verb|sqrt(a)*ket(0,0)+ sqrt(1-a)*ket(1,1)|. This
only works for qubits ($d=2$). Note that you may need to
enter \verb|assume(a>0,1-a>0)|\ibd{assume} when manipulating this state.
The \maxman{\fs{assume}}{\maximaassume}\maxcom function is used to build
a database of facts used, for instance, by the \ifs{is} function.

\subsection{\fs{bell} and  \fs{belln} --- Bell state kets in computational basis$.$}
\ibd{bell}\ibd{belln}
\index{Bell states}
create vector bell states. \fs{bell[a,b]} creates the state
\begin{equation}
 \ket{\Psi_{a,b}} = \frac{1}{\sqrt{2}} \ket{0,b} + (-1)^a  \ket{1,\bar b},
\end{equation}
where $a,b\in\{0,1\}$. The array \fs{belln[i]} creates the same states
where $i$ is the decimal representation of the binary numeration
$(a,b)$. That is, $(0,1,2,3)$ corresponds to $( (0,0), (0,1), (1,0), (1,1) )$.
Note that \fs{belln[i]} is a \pname{Maxima} 
\umaxman{array}{\maximaArrays} as indicated by the square
brackets.

As an exercise, we will check our definitions of the Bell
states by testing for orthonormality. \index{orthonormality!of Bell states} We first define an array
function \index{arrays!array functions} that returns the inner product of two Bell states.
An array function \fs{f[x,y]} is like an ordinary function
\fs{f(x,y)} except that it can be used where an array is
expected.
\bbm
\begin{verbatim}
(%i2) f[x,y] := belln[x] . belln[y];
\end{verbatim}
\begin{dmath}[number={\%o2}]
 f_{x,\linebreak[0]y}:=\mathrm{belln}_{x}\cdot \mathrm{belln}_{y}\end{dmath}
\ebm
Create a $4 \times 4$ matrix with \maxman{\fs{genmatrix}}{\maximagenmatrix}\maxcom\ibd{genmatrix}
 which maps the two dimension array \fs{f} over the indices of the matrix with the given range.
\bbm
\begin{verbatim}
(%i3) genmatrix( f , 3,3,0,0);
\end{verbatim}
\begin{dmath}[number={\%o3}]
  \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr
    0&\linebreak[0]1&\linebreak[0]0&\linebreak[0]0\cr
    0&\linebreak[0]0&\linebreak[0]1&\linebreak[0]0\cr
    0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr
  }\end{dmath}
\ebm
But instead of the named function \fs{f} we could have used
just a function body with the 
\maxman{\fs{lambda}}{\maximalambda}\maxcom \ibd{lambda} function,
which returns a function that is not bound to a symbol.
\bbm
\begin{verbatim}
(%i4) genmatrix( lambda( [x,y], belln[x] . belln[y]) , 3,3,0,0);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{1&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]1&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]1&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1\cr }\end{dmath}
\ebm
It is obviously the $4 \times 4$ identity matrix.  The
function \ifunc{identitymatrixp}{mat} \index{identity matrix!testing for}
 is a predicate defined in the
quantum information package in analogy to the \pname{Maxima}
function \umaxman{zeromatrixp}{\maximazeromatrixp}.
 It returns \fs{true} only if its
argument is an identity matrix. (The symbol 
%\verb|%| 
\%
refers to the previous output.
\bbm
\begin{verbatim}
(%i5) identitymatrixp(%);
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{true}\end{dmath}
\ebm
In the following sections, we often perform these comparisons in a single line. This
is how the test appears in the regression test suite.
\bbm
\begin{verbatim}
(%i6) identitymatrixp(genmatrix( lambda( [x,y], belln[x] . belln[y]) , 3,3,0,0));
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \mathbf{true}\end{dmath}
\ebm
We see that these four vectors are orthonormal and thus form a basis in $\mathbb{C}^2\otimes \mathbb{C}^2$.
We can also check that
\begin{equation}
 \ket{\Psi_{00}}\bra{\Psi_{00}} +  \ket{\Psi_{01}}\bra{\Psi_{01}}
  + \ket{\Psi_{10}}\bra{\Psi_{10}} + \ket{\Psi_{11}}\bra{\Psi_{11}} = \mathbb{1}_4.
\end{equation}
\bbm
\begin{verbatim}
(%i2) identitymatrixp(apply("+",map(lambda([i],proj(belln[i])),[0,1,2,3])));
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \mathbf{true}\end{dmath}
\ebm

\subsection{\fs{ghz} and  \fs{ghzn} --- GHZ state kets$.$}
\ibd{gzh}\ibd{gzhn}
The array \marray{ghz}{i,j,k} contains the GHZ kets defined by
\begin{equation}
 \ket{\Psi_{\mbox{GHZ}}(a,b,c)} 
 = \frac{1}{\sqrt{2}} \ket{0,b,c} + (-1)^a  \ket{1,\bar b,\bar c},
\end{equation}
where the bar denotes the logical not operation.
The array \marray{ghzn}{n} is the same array indexed by a single
decimal number equivalent to the binary numeration given by $a,b,c$.

\subsection{\fs{werner} --- Werner state density matrix$.$}
\ibd{werner}
The Werner state is defined by 
$$
 \ket{\Psi(\lambda,i,j)}_{\mbox{Werner}} =
  \lambda \ket{\Psi(i,j)}_{\mbox{Bell}}\bra{\Psi(i,j)}_{\mbox{Bell}}
   + (1-\lambda) \rho_u,
$$
where $\rho_u=\mathbb{1}_4/4$. The \pname{qinf} function
is \verb|werner(a,i,j)|.
 The entropy \index{entropy!of Werner state} depends on neither $i$ nor $j$ and varies with $\lambda$ between
a value of $0$ and $1$ per bit, as the state is tuned from a pure state to 
the uniform mixed state.
\bbm
\begin{verbatim}
(%i2) wxplot2d(entropy(werner(a,1,0)), [a,0,1]);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \includegraphics[width=.5\linewidth]{figs/werner_entropy}
\end{dmath}
\ebm

\htmlrule
\section{Creating and using operators}

\subsection{Pauli matrices}\index{pauli matrices}
\subsubsection{\fs{pauli} --- Pauli matrices$.$}
\ibd{pauli}
\marray{pauli}{i}
creates the Pauli matrices $(\sigma_0,\sigma_1,\sigma_2,\sigma_3)
=(\mathbb{1}_2,\sigma_x,\sigma_y,\sigma_z).$
\bbm
\begin{verbatim}
(%i12) [ pauli[0], pauli[1], pauli[2], pauli[3] ];
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \left[ \pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]1\cr },\linebreak[0]\pmatrix{0&\linebreak[0]1\cr 1&\linebreak[0]0\cr },\linebreak[0]\pmatrix{0&\linebreak[0]-i\cr i&\linebreak[0]0\cr },\linebreak[0]\pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]-1\cr } \right] \end{dmath}
\ebm
Show that the ket $\ket{1}_x$ is an eigenvector of $\sigma_x$ with eigenvalue $-1$.
\bbm
\begin{verbatim}
(%i8) is (  pauli[1] . ket_n(1,1) = -1 * ket_n(1,1) );
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \mathbf{true}\end{dmath}
\ebm
Here are we check that all our definitions of the Pauli matrices and kets are
consistent in this sense.
\bbm
\begin{verbatim}
(%i9) mapapply( lambda([i,j], is (pauli[i] . ket_n(i,j) = (-1)^j * ket_n(i,j))),
         [[1,0],[1,1],[2,0],[2,1],[3,0],[3,1]  ]);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \left[ \mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true} \right] \end{dmath}
\ebm

Here we use \func{anticommutator}{op_1,op_2} \ibd{anticommutator} to test the anticommutation relations among
the Pauli matrices: $\{\sigma_i,\sigma_j\}= 2\delta_{i,j}$ for $i,j \in\{1,2,3\}.$
\bbm
\ibd{genmatrix}
\begin{verbatim}
(%i3) genmatrix(lambda([i,j],  anticommutator(pauli[i],pauli[j])/2 ), 3,3,1,1);
\end{verbatim}
\begin{dmath}[number={\%o3}]
  \pmatrix{\pmatrix{1&\linebreak[0]0\cr 0&\linebreak[0]1\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr }\cr \pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{1&\linebreak[0]0\cr
      0&\linebreak[0]1\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr }\cr \pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{0&\linebreak[0]0\cr
      0&\linebreak[0]0\cr
    }&\linebreak[0]\pmatrix{1&\linebreak[0]0\cr
      0&\linebreak[0]1\cr }\cr }\end{dmath}
\ebm 
The \pname{Maxima} function 
\umaxman{mat\_unblocker}{\maximamatUunblocker}\index{block matrix!flattening block structure},
 flattens the
blocks in the above expression, so we can write \bbm
\begin{verbatim}
(%i4) identitymatrixp( mat_unblocker (genmatrix(lambda([i,j],  
         anticommutator(pauli[i],pauli[j])/2 ), 3,3,1,1)));
\end{verbatim}
\begin{dmath}[number={\%o4}]
  \mathbf{true}\end{dmath} \ebm Now we load the
\umaxman{itensor}{\maximaitensor} package, which provides the \index{levi-civita
  tensor} \umaxman{levi-civita}{\maximaleviUcivita} tensor, and make use of the
\pname{Maxima} functions 
\umaxman{permutations}{\maximapermutations}
(which returns
the \maxman{set}{\maximaSets} of all permutations of a list)
and \umaxman{listify}{\maximalistify} (which converts the set data type into the (ordered) list data type).
The \qinf package provides \ibd{mapapply}
\func{mapapply}{func,[list1, list2,\ldots]}, which
\ifs{apply}s \farg{func} to each of the \farg{list}s and
returns a list of the results.  (see the \pname{Maxima}
documentation for
 \umaxman{apply}{\maximaapply}.)  With all these, we can test
the commutation relations \index{commutator} of the Pauli
matrices. (In reality, the matrix definitions are not
complicated, we are actually testing the other functions.):
$[\sigma_i,\sigma_j] = 2i\epsilon_{i,j,k}\sigma_k$.  \bbm
\begin{verbatim}
(%i5) load("itensor");
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \verb|/usr/share/maxima/5.15.0/share/tensor/itensor.lisp|\end{dmath}
\begin{verbatim}
(%i6) mapapply(lambda([i,j,k],zeromatrixp(commutator(pauli[i],pauli[j]) 
     - 2*%i*levi_civita([i,j,k])*pauli[k])), listify(permutations([1,2,3])));
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \left[ \mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true},\linebreak[0]\mathbf{true} \right] \end{dmath}
\ebm

\subsubsection{{\bf pauli\_product} ---  tensor product of Pauli matrices$.$}
\ibd{pauli\_product}
\func{pauli\_product}{i_1,\ldots,i_n} returns the tensor product
$\sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}$, where the indices
$i_j$ are in $\{0,1,2,3\}$. As elsewhere in this document, $\sigma_0$ is
the $2\times 2$ identity matrix.

The next three functions 
\func{pauliexp}{\rho}, \func{invpauliexp}{c}, and \func{correlation\_tensor}{c,i_1,\ldots,i_n}
are related. An example using them follows their definitions.

\subsubsection{\fs{pauliexp} --- expansion of operator in terms of tensor products of Pauli matrices$.$}
\ibd{pauliexp}\index{expansion!in pauli matrices}
\func{pauliexp}{\rho} returns the correlation tensor,
\index{correlation tensor}
 that is, the coefficients in the expansion of the matrix $\rho$
in tensor products of Pauli matrices. Explicitly, \fs{pauliexp}
returns the coefficients $c_{i_1,\ldots,i_n}$ in
\begin{equation}\label{pauliexp}
 \rho = \sum_{i_1,\ldots,i_n=0}^3 c_{i_1,\ldots,i_n} \ \sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}.
\end{equation}
$\rho$ must be a $2^n\times 2^n$ matrix. The coefficients are returned as a list
of $2^n\times 2^n$ elements. The place of $c_{i_1,\ldots,i_n}$ in the returned list is determined
by taking ${i_1,\ldots,i_n}$ to be the  binary representation of an integer. For convenience,
the coefficient can be retrieved by index with the function \fs{correlation\_tensor}.

\subsubsection{\fs{invpauliexp} --- inverse of expansion in terms of tensor products of Pauli matrices$.$}
\ibd{invpauliexp}\index{expansion!inverse of expansion in Pauli matrices}
\func{invpauliexp}{c} is the inverse of \fs{pauiexp}. Given a list $c$ representing
the correlation tensor (i.e. expansion coefficients),
 \fs{invpauliexp} returns the matrix $\rho$ given by (\ref{pauliexp}).

\subsubsection{\fs{correlation\_tensor} --- retrieve component of correlation tensor by index$.$}
\ibd{correlation\_tensor}
\func{correlation\_tensor}{c,i_1,\ldots,i_n} returns the expansion coefficient for
the term $\sigma_{i_1} \otimes \cdots \otimes \sigma_{i_n}$ in the expansion of
$\rho$, where $c$ is the list of coefficients in the expansion of $\rho$ as given,
for instance, by \fs{pauliexp}.

\subsubsection{Using \fs{pauliexp} and \fs{invpauliexp}; an example$.$}
Here is an example using the three functions defined above.
First we create three generic $2\times2$ (complex) matrices.
\bbm
\begin{verbatim}
(%i2) m1 : matrix([a1,b1],[c1,d1]);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\mathrm{a1}&\linebreak[0]\mathrm{b1}\cr \mathrm{c1}&\linebreak[0]\mathrm{d1}\cr }\end{dmath}
\begin{verbatim}
(%i3) m2 : matrix([a2,b2],[c2,d2]) $
(%i4) m3 : matrix([a3,b3],[c3,d3]) $
\end{verbatim}
\ebm
Here is the tensor product of the three matrices. This is {\it not} a generic element in
the three qubit Hilbert space represented by $M(\mathbb{C},8)$. For instance,
the three matrices have $12$ complex parameters while a generic matrix in
the tensor product space  has $64$ complex parameters.
\bbm
\begin{verbatim}
(%i5) mp : m1 otimes m2 otimes  m3 ;
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{\mathrm{a1}\*\mathrm{a2}\*\mathrm{a3}&\linebreak[0]\mathrm{a1}\*\mathrm{a2}\*\mathrm{b3}&\linebreak[0]\mathrm{a1}\*\mathrm{a3}\*\mathrm{b2}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{b3}&\linebreak[0]\mathrm{a2}\*\mathrm{a3}\*\mathrm{b1}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{b3}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{b3}\cr \mathrm{a1}\*\mathrm{a2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{a2}\*\mathrm{d3}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{b2}\*\mathrm{d3}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{c3}&\linebreak[0]\mathrm{a2}\*\mathrm{b1}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{c3}&\linebreak[0]\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}\cr \mathrm{a1}\*\mathrm{a3}\*\mathrm{c2}&\linebreak[0]\mathrm{a1}\*\mathrm{b3}\*\mathrm{c2}&\linebreak[0]\mathrm{a1}\*\mathrm{a3}\*\mathrm{d2}&\linebreak[0]\mathrm{a1}\*\mathrm{b3}\*\mathrm{d2}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}&\linebreak[0]\mathrm{b1}\*\mathrm{b3}\*\mathrm{c2}&\linebreak[0]\mathrm{a3}\*\mathrm{b1}\*\mathrm{d2}&\linebreak[0]\mathrm{b1}\*\mathrm{b3}\*\mathrm{d2}\cr \mathrm{a1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{a1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{a1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{a1}\*\mathrm{d2}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{b1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{b1}\*\mathrm{d2}\*\mathrm{d3}\cr \mathrm{a2}\*\mathrm{a3}\*\mathrm{c1}&\linebreak[0]\mathrm{a2}\*\mathrm{b3}\*\mathrm{c1}&\linebreak[0]\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}&\linebreak[0]\mathrm{b2}\*\mathrm{b3}\*\mathrm{c1}&\linebreak[0]\mathrm{a2}\*\mathrm{a3}\*\mathrm{d1}&\linebreak[0]\mathrm{a2}\*\mathrm{b3}\*\mathrm{d1}&\linebreak[0]\mathrm{a3}\*\mathrm{b2}\*\mathrm{d1}&\linebreak[0]\mathrm{b2}\*\mathrm{b3}\*\mathrm{d1}\cr \mathrm{a2}\*\mathrm{c1}\*\mathrm{c3}&\linebreak[0]\mathrm{a2}\*\mathrm{c1}\*\mathrm{d3}&\linebreak[0]\mathrm{b2}\*\mathrm{c1}\*\mathrm{c3}&\linebreak[0]\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}&\linebreak[0]\mathrm{a2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{a2}\*\mathrm{d1}\*\mathrm{d3}&\linebreak[0]\mathrm{b2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{b2}\*\mathrm{d1}\*\mathrm{d3}\cr \mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}&\linebreak[0]\mathrm{b3}\*\mathrm{c1}\*\mathrm{c2}&\linebreak[0]\mathrm{a3}\*\mathrm{c1}\*\mathrm{d2}&\linebreak[0]\mathrm{b3}\*\mathrm{c1}\*\mathrm{d2}&\linebreak[0]\mathrm{a3}\*\mathrm{c2}\*\mathrm{d1}&\linebreak[0]\mathrm{b3}\*\mathrm{c2}\*\mathrm{d1}&\linebreak[0]\mathrm{a3}\*\mathrm{d1}\*\mathrm{d2}&\linebreak[0]\mathrm{b3}\*\mathrm{d1}\*\mathrm{d2}\cr \mathrm{c1}\*\mathrm{c2}\*\mathrm{c3}&\linebreak[0]\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}&\linebreak[0]\mathrm{c1}\*\mathrm{c3}\*\mathrm{d2}&\linebreak[0]\mathrm{c1}\*\mathrm{d2}\*\mathrm{d3}&\linebreak[0]\mathrm{c2}\*\mathrm{c3}\*\mathrm{d1}&\linebreak[0]\mathrm{c2}\*\mathrm{d1}\*\mathrm{d3}&\linebreak[0]\mathrm{c3}\*\mathrm{d1}\*\mathrm{d2}&\linebreak[0]\mathrm{d1}\*\mathrm{d2}\*\mathrm{d3}\cr }\end{dmath}
\ebm
We compute the correlation tensor of \verb|mp|
\bbm
\begin{verbatim}
(%i6) pe : pauliexp(mp) $
\end{verbatim}
\ebm
Check that the tensor has $64$ elements and see what a coefficient looks like.
\bbm
\begin{verbatim}
(%i7) length(pe);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 64\end{dmath}
\begin{verbatim}
(%i8) part(pe,10);
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \ifracn{-i\*\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}-i\*\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}+i\*\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}+i\*\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}-i\*\mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}-i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}+i\*\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}+i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}}{8}\end{dmath}
\ebm
Check that the inverse of the expansion gives the original matrix back
\bbm
\begin{verbatim}
(%i9) is ( ratsimp( invpauliexp( pauliexp(mp) )) = mp);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \mathbf{true}\end{dmath}
\ebm
Here is the convenience function to return an element of the correlation tensor by index
\bbm
\begin{verbatim}
(%i10) correlation_tensor(pe,1,2,3);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \ifracn{i\*\mathrm{c1}\*\mathrm{c2}\*\mathrm{d3}+i\*\mathrm{b1}\*\mathrm{c2}\*\mathrm{d3}-i\*\mathrm{b2}\*\mathrm{c1}\*\mathrm{d3}-i\*\mathrm{b1}\*\mathrm{b2}\*\mathrm{d3}-i\*\mathrm{a3}\*\mathrm{c1}\*\mathrm{c2}-i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{c2}+i\*\mathrm{a3}\*\mathrm{b2}\*\mathrm{c1}+i\*\mathrm{a3}\*\mathrm{b1}\*\mathrm{b2}}{8}\end{dmath}
\ebm

\subsection{\fs{spinor\_rotation}, \fs{spinor\_rotation\_trig}$.$}
\ibd{spinor\_rotation}\ibd{spinor\_rotation\_trig}
\index{rotation!spinor}
\func{spinor\_rotation}{phi,theta,gamma} returns the matrix that represents
the operator that rotates a spinor through an angle \farg{gamma} about the axis specified by 
\farg{phi} (angle about the $z$-axis) and \farg{theta} (inclination from the $z$-axis). The function \func{spinor\_rotation\_trig}{phi,theta,gamma}
returns the same matrix expressed only with cosines and sines. This is the standard
axis-angle parameterization.  Explicitly the matrices are
\bbm
\begin{verbatim}
(%i2) spinor_rotation(phi,theta,gamma);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\cos \left(\frac{\gamma}{2}\right)-i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]-i\*\iexpt{e}{- i\*\varphi }\*\sin \vartheta\*\sin \left(\frac{\gamma}{2}\right)\cr -i\*\iexpt{e}{i\*\varphi}\*\sin \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)+\cos \left(\frac{\gamma}{2}\right)\cr }\end{dmath}
\begin{verbatim}
(%i3) spinor_rotation_trig(phi,theta,gamma);
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{\cos \left(\frac{\gamma}{2}\right)-i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]\left(-\sin \varphi\*\sin \vartheta-i\*\cos \varphi\*\sin \vartheta\right)\*\sin \left(\frac{\gamma}{2}\right)\cr \left(\sin \varphi\*\sin \vartheta-i\*\cos \varphi\*\sin \vartheta\right)\*\sin \left(\frac{\gamma}{2}\right)&\linebreak[0]i\*\cos \vartheta\*\sin \left(\frac{\gamma}{2}\right)+\cos \left(\frac{\gamma}{2}\right)\cr }\end{dmath}.
\ebm

\subsection{\fs{insert\_operator} --- insert single qubit operators in $n$-qubit operator}
 \ibd{insert\_operator}
\func{insert\_operator}{nbits,[op1,i1,i2,..],[op2,j2,j2,...],...} returns
the operator $\mathbb{1}_2^{\otimes \mbox{nbits}}$, with some of the identity operators
$\mathbb{1}_2$ substituted by the operators \farg{op1,op2,\ldots} at the indices specified
by the indices $i1,i2,\ldots,j1,j2,\ldots$. Each replacement operator replaces a single
qubit identity operator $\mathbb{1}_2$, even if the replacement operator has dimension
other than $2$. 
 For example

\begin{center} 
\verb|insert_operator(8,[pauli[1],1,3],[pauli[2],2,5],[pauli[3],8])|
\end{center}
returns
$$
\sigma_x \otimes \sigma_y \otimes \sigma_x \otimes \mathbb{1}_2 
  \otimes \sigma_y \otimes  \mathbb{1}_2 \otimes  \mathbb{1}_2   \otimes \sigma_z.
$$
\fs{insert\_operator} is used to build the operators and gates listed below.

\subsection{Gates}
\index{gates}
\subsubsection{\fs{hadamard} operator$.$}
\ibd{hadamard}
\pname{qinf} defines both a variable and a function named \fs{hadamard}.
The value of the  variable \fs{hadamard} is as follows,
\bbm
\begin{verbatim}
(%i2) hadamard;
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\ifracd{1}{\isqrt{2}}&\linebreak[0]\ifracd{1}{\isqrt{2}}\cr \ifracd{1}{\isqrt{2}}&\linebreak[0]-\ifracd{1}{\isqrt{2}}\cr }\end{dmath}
\ebm
The function \func{hadamard}{nbits,i1,i2,\ldots}  returns the tensor product
of \farg{nbits} one-qubit operators each of which is $\mathbb{1}_2$ except
for the operators in positions \farg{i1,i2,\ldots} which are the hadamard
operator given by the variable \fs{hadamard}. The function is defined
by
\begin{verbatim}
hadamard(nbits,[t]) := insert_operator(nbits,cons(hadamard,t)),
\end{verbatim}
which is an idiom that will work for similar user defined functions as well.
The dummy argument \verb|[t]| causes all arguments after \verb|nbits| to
be collected in a single list. The \pname{Maxima} function 
\umaxman{cons}{\maximacons}, invoked as \func{cons}{expr,list},
returns the list given by  prepending 
 \verb|expr| to the list \verb|list|. 

\subsubsection{\fs{controlled\_gate} --- gate with $n$ control qubits}
\ibd{controlled\_gate}
A controlled gate applies an operator $m$ to a single qubit (the target) in a register only if
each of a set of control qubits is set. Otherwise the operator is equivalent to
the identity operator. In any case, the operator is the identity on every
qubit other than the target.
The function \func{controlled\_gate}{nbits,qop,t,clst}
creates a controlled gate with one or more control qubits embedded in
a \verb|nbits|-qubit operator. The target qubit is at the index \verb|t|,
while the control qubits are at the indices listed in the list \verb|clst|.
In the returned operator, the $\mathbb{1}_2$ operator is at the remaining positions.
The controlled gate operator applies \verb|qop| at qubit \verb|t| if all of
the control qubits are set (i.e. are $1$) and is equivalent to the identity operator
otherwise.
For instance a \fs{cnot}\index{cnot} operator on $H_2\otimes H_2$ is given by
\verb|controlled_gate(2,pauli[1],2,[1])|.
The controlled gate in an $n$-qubit space with $n-1$ control bits and
the $1$-qubit target operator $m$ is implemented in \pname{qinf} as
$$
 \mathbb{1}_{2^n} + \left(\ket{1}\bra{1}\right)^{\otimes{n-1}}
    \otimes (m-\mathbb{1}_2).
$$
In the case that this  controlled gate operator is embedded in an operator in a larger space,
the same formula is used, with additional factors of $\mathbb{1}_2$ inserted at the 
appropriate places. Also the target qubit may occupy any index. This is implemented
via the \fs{insert\_operator} function described above.

\subsubsection{\fs{cnot}, \fs{cphase}, \fs{crot}$.$}
\ibd{cnot}\ibd{cphase}\ibd{crot}
 \func{cnot}{nbits,t,c1,c2,\ldots} returns a cnot gate on an \verb|nbits|-qubit
register with the target at index \verb|t| and control qubits at indices
\verb|c1,c2,...|. The definition of this function is
\verb|cnot(nbits,t,[c]) := controlled_gate(nbits,pauli[1],t,c)|.
The functions \fs{cphase} and \fs{crot} are defined in the same way except
that operators \verb|pauli[3]| and  \verb|%i*pauli[2]| respectively are
substituted for \verb|pauli[1]|. For example, the elementary cnot gate
is given by \verb|cnot(2,2,1)|.
\subsubsection{\fs{swap}$.$}
\ibd{swap}
\func{swap}{nbits,t1,t2} returns the operator that swaps qubits \verb|t1|
and \verb|t2| in an  \verb|nbits|-qubit register. It is defined by
\verb|swap(nbits,t1,t2) := cnot(nbits,t1,t2) . cnot(nbits,t2,t1) . cnot(nbits,t1,t2)|.
\subsubsection{\fs{toffoli}$.$}
\ibd{toffoli}
This function is provided for convenience. It is defined by
\verb|toffoli(nbits,t,c1,c2) := cnot(nbits,t,c1,c2)|. Note that there
are exactly two control qubits.
\subsubsection{\fs{fredkin}$.$}
\ibd{fredkin}
\func{fredkin}{nbits,t1,t2,c} is controlled swap operator. The qubits at indices
\verb|t1| and \verb|t2| are swapped if the control qubit at index \verb|c| is set.
\htmlrule
%\section{Entanglement-- \func{ptrace}{\rho,i_1,\ldots}, \func{entropy}{\rho}, \func{purity}{\rho}$.$}
\section{Entanglement}

Now we are ready to introduce features that are more
specific to the study quantum entanglement. Included here
are measures of the degree of purity and measures
of the degree of entanglement. For a review of quantum
entanglement, see Ref.\cite{HHH08}.

% namely the partial trace \fs{ptrace}, the von Neumann entropy
%\fs{entropy} and \fs{purity}.


\subsection{\fs{ptrace}, \fs{ptracen} --- partial trace$.$}
\ibd{ptrace}\ibd{ptracen}
\index{trace!partial trace of matrix}
compute the partial trace of the  density 
operator $\rho$ over the component spaces given by the indices.
For \ifunc{ptrace}{\rho,i_1,\ldots} the density matrix $\rho$ is assumed to represent
an operator in
$(H_2)^{\otimes m}$, with $n=2$, that is
a tensor product of qubit spaces. For \ifunc{ptracen}{n,\rho,i_1,\ldots} the component
spaces are all $n$-state qudits.

In this example we create three completely generic $3\times3$ matrices, and check that
$$
\mbox{Tr}_{1,2}\left(m_1\otimes m_2\otimes m_3\right) = \left(\mbox{Tr}(m_1)\mbox{Tr}(m_2)\right) m_3
$$
and that
$$
\mbox{Tr}_{3}\left(m_1\otimes m_2\otimes m_3 \right) = \mbox{Tr}(m_3)(m_1\otimes m_2).
$$
 Notice that we use the \pname{Maxima} function 
\umaxman{ratsimp}{\maximaratsimp} to put both sides of the
equation in the same canonical form.  We also make
use of the
 \umaxman{mat\_trace}{\maximamatUtrace}\index{trace!of matrix}
 function ( so named to avoid conflicting
with the code-execution trace function) and the
\umaxman{matrix}{\maximamatrix} function, which creates a matrix
from a list of rows. \index{matrix!trace} \index{matrix!creating}
\bbm
\begin{verbatim}
(%i1) m1 : matrix([a1,b1,c1],[d1,e1,f1],[g1,h1,i1])$

(%i2) m2 : matrix([a2,b2,c2],[d2,e2,f2],[g2,h2,i2])$

(%i3) m3 : matrix([a3,b3,c3],[d3,e3,f3],[g3,h3,i3])$

(%i4) is ( ratsimp( ptracen(3, m1 otimes m2 otimes m3 , 1,2) = 
            mat_trace(m1)*mat_trace(m2)*m3));
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \mathbf{true}\end{dmath}
\begin{verbatim}
(%i5) is ( ratsimp( ptracen(3, m1 otimes m2 otimes m3 ,3) = mat_trace(m3)* m1 otimes m2));
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{true}\end{dmath}
\ebm
Here we trace over one component repeatedly and check that the result is
equal to the full trace. Note that, each time, we are tracing over the new
first component.
\bbm
\begin{verbatim}
(%i10) factor( ptracen(3,ptracen(3,ptracen(3,m1 otimes m2 otimes m3,1),1),1));
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\left(\mathrm{i1}+\mathrm{e1}+\mathrm{a1}\right)\*\left(\mathrm{i2}+\mathrm{e2}+\mathrm{a2}\right)\*\left(\mathrm{i3}+\mathrm{e3}+\mathrm{a3}\right)\cr }\end{dmath}
\ebm

\subsection{\fs{entropy} --- von Neumann entropy$.$}
\ibd{entropy}
\index{entropy!von Neumann}
\func{entropy}{\rho} returns the von Neumann \fs{entropy} of
the density matrix $\rho$  defined by
\begin{equation}
 S(\rho) = -\mbox{Tr}\left(\rho \log_2 \rho\right).
\end{equation}
\ifs{entropyf} is the floating point version of \fs{entropy}.

\subsection{\fs{renyi\_entropy}$.$}
\ibd{renyi\_entropy}
\index{entropy!R\'enyi}
 \func{renyi\_entropy}{alpha,rho} gives the R\'enyi entropy, defined by
\begin{equation}
 S_{\mbox{renyi}}(\alpha,\rho) = \frac{1}{1-\alpha}\log_2\left(\mbox{Tr}(\rho^\alpha)\right).
\end{equation}
\ifs{renyi\_entropyf} is the floating point version of \fs{renyi\_entropy}.

\subsection{\fs{tsallis\_entropy}$.$}
\ibd{tsallis\_entropy}
\index{entropy!Tsallis}
 \func{tsallis\_entropy}{q,rho} gives the Tsallis entropy, defined by
\begin{equation}
 S_{\mbox{tsallis}}(q,\rho) = \frac{1}{q-1}\left(1-\mbox{Tr}(\rho^q)\right).
\end{equation}
\ifs{tsallis\_entropyf} is the floating point version of \fs{tsallis\_entropy}.

\subsection{\fs{purity}$.$}
\ibd{purity}
 \func{purity}{\rho} returns the purity of the 
density matrix $\rho$ defined by $\mbox{Tr}(\rho^2)$. The purity
is $1$ for a pure state and is less than $1$ for a mixed state.

\subsection{\fs{fidelity}$.$}
\ibd{fidelity}
\func{fidelity}{\rho_1,\rho_2} returns the scalar valued fidelity
of the density matrices $\rho_1$ and $\rho_2$ defined by
$$
 \mbox{Tr}\left(\sqrt{\sqrt{\rho_2}\rho_1\sqrt{\rho_2}}\right).
$$

\subsection{\fs{concurrence} --- Wootters'  concurrence$.$}
\ibd{concurrence}\index{Wootters}
The concurrence of a two-qubit state $\rho$ is defined by 
$\max(0,\sqrt{\lambda_1}-\sqrt{\lambda_2}-\sqrt{\lambda_3}-\sqrt{\lambda_4}$),
where the $\lambda_i$ are the eigenvaluse of
$$
  \rho (\sigma_y \otimes \sigma_y) \rho^{\mbox{*}} (\sigma_y \otimes \sigma_y),
$$
in decreasing order\cite{Wootters97}

\verb|concurrence(rho)| returns the concurrence of the state \verb|rho|.
\verb|concurrence_vals(rho)| returns a list of the square roots of
the eigenvalues in decreasing order, to the extent that \pname{Maxima}
can determine the order.

\subsection{\fs{separable} --- test for separability$.$}\index{separability}
\ibd{separable}
This currently accepts only pure, bipartite states.
\func{separable}{e} attempts to determine if \farg{e} is a separable
state. \fs{separable} returns a scalar value $r$. If $r=1$, then
\farg{e} is separable. If $r<1$, it is not. Explicitly, the value
returned for the state with density operator $\rho_{AB}$ 
is $\mbox{Tr}(\rho_A^2)$

\subsection{Example: An entangled pure global state has mixed reduced states}
We examine a textbook example of entanglement--- the
pure join state of two qubits. The state of the whole system is pure,
but the local states are mixed.  We begin by creating a
joint state of two qubits in Schmidt basis
$\ket{\alpha}=\sqrt{\alpha}\ket{00}+
\sqrt{1-\alpha}\ket{11}.$ In order to see the mixed
character of the local states, we need to express the full
state as a density operator (or equivalently as a projection
operator.) Let's try to make $\ket{\alpha}\bra{\alpha}$.
\bbm
\begin{verbatim}
(%i2)  pr : proj(schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \pmatrix{\isqrt{\alpha}^{\star}\*\isqrt{\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}^{\star}\*\isqrt{\alpha}\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr \isqrt{\alpha}^{\star}\*\isqrt{1-\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}^{\star}\*\isqrt{1-\alpha}\cr }
\end{dmath}
\ebm
We see that \pname{Maxima} is allowing that the quantities under the radicals may be negative. So
we set some rules, and try again. \ibd{assume}
\bbm
\begin{verbatim}
(%i3) assume(alpha>0, 1-alpha>0);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \left[ \alpha>0,\linebreak[0]\alpha<1 \right] \end{dmath}
\begin{verbatim}
(%i5)  pr : proj(schmidt_ket(alpha));
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \pmatrix{\alpha&\linebreak[0]0&\linebreak[0]0&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr 0&\linebreak[0]0&\linebreak[0]0&\linebreak[0]0\cr \isqrt{1-\alpha}\*\isqrt{\alpha}&\linebreak[0]0&\linebreak[0]0&\linebreak[0]1-\alpha\cr }\end{dmath}
\ebm
The entropy \index{entropy!of a pure state}
 vanishes for a pure state, so that $S(\ket{\alpha}\bra{\alpha})$ is
\bbm
\begin{verbatim}
(%i6)  entropy(pr);
\end{verbatim}
\begin{dmath}[number={\%o7}]
 0\end{dmath}
\ebm
The \ifs{purity} is equal to $1$ if and only if $\rho$ is a pure state.
\bbm
\begin{verbatim}
(%i8) purity(pr);
\end{verbatim}
\begin{dmath}[number={\%o8}]
 \alpha^{2}+2\*\left(1-\alpha\right)\*\alpha+\left(1-\alpha\right)^{2}\end{dmath}
The above line should be 
\maxman{simplified}{maxima_7.html#SEC29} by writing it as a canonical rational expression (CRE)
\ibd{ratsimp} \index{canonical rational expression}
\begin{verbatim}
(%i9) ratsimp(%);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 1\end{dmath}
\ebm
Now we compute the reduced density matrix of the second qubit by tracing over the first---
$\rho_2=\mbox{Tr}_1 \ket{\alpha}\bra{\alpha}.$
\bbm
\begin{verbatim}
(%i10)  pr2 : ptrace(pr,1);
\end{verbatim}
\begin{dmath}[number={\%o10}]
 \pmatrix{\alpha&\linebreak[0]0\cr 0&\linebreak[0]1-\alpha\cr }\end{dmath}
\ebm
Tracing over the second qubit instead gives the same result
\bbm
\begin{verbatim}
(%i11) ptrace(pr,2);
\end{verbatim}
\begin{dmath}[number={\%o11}]
  \pmatrix{\alpha&\linebreak[0]0\cr
    0&\linebreak[0]1-\alpha\cr }\end{dmath} \ebm Computing
the entropy\index{entropy!of a reduced state} of a local state
shows that this state is, in general, mixed \bbm
\ibd{entropy}
\begin{verbatim}
(%i12) entropy(pr2);
\end{verbatim}
\begin{dmath}[number={\%o12}]
 -\alpha\*\mathrm{log2}\left(\alpha\right)-\mathrm{log2}\left(1-\alpha\right)\*\left(1-\alpha\right)\end{dmath}
\ebm
Each eigenvalue $\lambda$ satisfies $0\le \lambda <1$, so that the sum of their squares is less than
one 
\bbm
\begin{verbatim}
(%i13) purity(pr2);
\end{verbatim}
\begin{dmath}[number={\%o13}]
  \alpha^{2}+\left(1-\alpha\right)^{2}\end{dmath} \ebm We
can plot \index{plotting} the results (the plot function \ifs{plot2d} is more
common, depending on your user interface. \ifs{wxplot2d} has
the same calling syntax, but inlines the resulting plot.) We
see that the maximum entanglement occurs at $\alpha=1/2$ and
decreases monotonically from there in both directions, with
$\alpha=0,1$ giving pure joint states.  \bbm
\begin{verbatim}
(%i14)  wxplot2d([entropy(pr2), purity(pr2)],[alpha,0,1]);
\end{verbatim}
\begin{dmath}[number={\%o14}]
\includegraphics[width=.5\linewidth]{figs/entropy_purity}
\end{dmath}
\ebm

\htmlrule
\section{More operators and functions}

Unless noted, all functions return either true or false.

\subsection{Predicate functions --- testing for properties}
\subsubsection{\fs{identitymatrixp} }\ibd{identitymatrixp}
 \index{identity matrix!testing for}
\func{identitymatrixp}{e} returns  true if \farg{e} is the $n\times n$ identity
 matrix for any $n$.
\subsubsection{\fs{ketp}, \fs{brap}, \fs{braketp}}\ibd{ketp}\ibd{brap}\ibd{braketp}
\func{ketp}{e} returns true if the expression \farg{e} is a ket
(column vector).
\func{brap}{e} returns true if the expression \farg{e} is a bra
(row vector).
 \func{braketp}{e}
returns \verb|(ketp(e) or brap(e))|, i.e. returns true if \farg{e} is either a ket or
a bra.
\subsubsection{\fs{square\_matp}}\ibd{square\_matp}
\func{square\_matp}{e} returns true if \farg{e} is a square matrix.
\subsection{Miscellaneous}
\subsubsection{\fs{normalize\_vector}}\ibd{normalize\_vector}
  \func{normalize\_vector}{v} returns $v/\bracket{v}{v}$.
\subsubsection{\fs{normalize\_operator}}\ibd{normalize\_matrix}
  \func{normalize\_matrix}{m} returns $m/\mbox{Tr}(m)$.

\htmlrule
\section{Reproducible research}

\subsection{Entanglement swapping\index{entanglement swapping}}

In this subsection, we check a calculation 
(appearing in Ref.~\cite{perseguers:022308})
that would
be relatively difficult to check by hand.
Consider a pair of entangled qubits $A$ and $B$, and another
entangled pair $C$ and $D$. By performing a joint
measurement on, say $B$ and $C$, we can put $A$ and $B$ in
an entangled state although they may be widely separated.
We begin by considering the most general projective measure
on $B$ and $C$, and calculate the reduced density matrix for
a single qubit and the probability of outcome. In this
example we calculate these quantities two ways--- one,
directly from the density matrix formalism, and two, via
formulas taking advantage of the particulars of this
problem. To do the first calculation by hand would be
extremely unpleasant, as it involves multiplying $16\times16$
matrices with several factors in a single element. Carrying
it out below with \pname{Maxima} is a concise exercise.

Qubits $A$ and $B$ are in the state
$$
\ket{\alpha}=\sqrt{\alpha}\ket{00}+ \sqrt{1-\alpha}\ket{11},
$$
$C$ and $D$ are in the state
$$
\ket{\beta}=\sqrt{\beta}\ket{00}+ \sqrt{1-\beta}\ket{11},
$$
with the Schmidt coefficients \index{Schmidt coefficients}
satisfying $\alpha,\beta >1/2$.
For now, we only want to tell \pname{Maxima} that the coefficients
of the kets are real.\ibd{assume}
 \bbm
\begin{verbatim}
(%i2) assume(alpha>0,1-alpha>0,beta>0,1-beta>0);
\end{verbatim}
\begin{dmath}[number={\%o2}]
 \left[ \alpha>0,\linebreak[0]\alpha<1,\linebreak[0]\beta>0,\linebreak[0]\beta<1 \right] \end{dmath}
\begin{verbatim}
(%i3) a : schmidt_ket(alpha);
\end{verbatim}
\begin{dmath}[number={\%o3}]
 \pmatrix{\isqrt{\alpha}\cr 0\cr 0\cr \isqrt{1-\alpha}\cr }\end{dmath}
\begin{verbatim}
(%i4) b : schmidt_ket(beta);
\end{verbatim}
\begin{dmath}[number={\%o4}]
 \pmatrix{\isqrt{\beta}\cr 0\cr 0\cr \isqrt{1-\beta}\cr }\end{dmath}
\ebm
We consider the projective measurement\index{projective measure} $\{E_m\}$, that is $E_m=\ket{u_m}\bra{u_m}$
and $\sum_m E_m=\mathbb{1}_4$. We consider only a single basis vector
here, so we don't use the subscript $m$ for \pname{Maxima} vector name.
We need to use the
\umaxman{declare}{\maximadeclare} function to declare that 
the components are complex. \index{complex numbers!declaring variable complex}
The state $\ket{u_m}$ is normalized, but we don't need to impose that condition in
\pname{Maxima} at this point.
\bbm
\begin{verbatim}
(%i5)  declare([u00,u01,u10,u11], complex);
\end{verbatim}
\begin{dmath}[number={\%o5}]
 \mathbf{done}\end{dmath}
\begin{verbatim}
(%i6) u : ket(u00,u01,u10,u11);
\end{verbatim}
\begin{dmath}[number={\%o6}]
 \pmatrix{\mathrm{u00}\cr \mathrm{u01}\cr \mathrm{u10}\cr \mathrm{u11}\cr }\end{dmath}
\ebm
The initial joint state $\ket{\alpha\beta}\bra{\alpha\beta}$ is pure and remains
so after the measurement applying $\ket{u_m}\bra{u_m}$ to qubits $B$ and $C$.
But we write the density operator
because we will examine the reduced states, which are mixed.
In the case that $B$ and $C$ are projected onto $\ket{u_m}$, the state
of the entire system of four qubits after the measurement is given by
\begin{equation}
  \rho = \left( (\mathbb{1}_2 \otimes \ket{u_m}\bra{u_m} \otimes \mathbb{1}_2 )
     \ket{\alpha\beta}\bra{\alpha\beta}\right),   
\end{equation}
with
\bbm
\begin{verbatim}
(%i7) rho : conjsimp((ident(2) otimes proj(u) otimes ident(2)) . proj(a otimes b))$,
\end{verbatim}
\ebm
where \ifs{conjsimp} 
(supplied via the \pname{Maxima} listserv by Barton Willis) replaces $xx^*$ with $|x|^2$,
and $\ifunc{ident}{n}$ \index{identity matrix!creating} is the $n\times n$ identity matrix.
The output was suppressed with the trailing dollar sign because the $\rho$ is
a $16\times16$ matrix with large expressions for entries.
%\everymath{\scriptscriptstyle}
%\newcommand{\myrm}[1]{\scriptscriptstyle{#1}}
%\newcommand{\mylineb}{\scriptscriptstyle \linebreak[0] \scriptscriptstyle }
%\newcommand{\myalpha}{\scriptscriptstyle \alpha }
%\newcommand{\myisqrt}[1]{\scriptscriptstyle\sqrt{#1}}
The reduced state of qubits $A$ and $D$ is obtained by tracing out components $2$ and
$3$ corresponding to qubits $B$ and $C$, i.e. $\rho_{AD} =\mbox{Tr}_{BC}\rho$.
\ibd{ptrace}
\bbm
\begin{verbatim}
(%i8) rho_14 : ptrace(rho,2,3);
\end{verbatim}
\begin{dmath}[number={\%o8},style={\tiny}]
 \pmatrix{\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\*\mathrm{u00}^{\star}\*\mathrm{u10}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u11}\cr \alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u01}^{\star}\*\mathrm{u10}&\linebreak[0]\left(\isqrt{1-\alpha}\*\isqrt{\alpha}-\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\right)\*\mathrm{u01}^{\star}\*\mathrm{u11}\cr \isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\*\mathrm{u00}\*\mathrm{u10}^{\star}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u01}\*\mathrm{u10}^{\star}&\linebreak[0]\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}\cr \isqrt{1-\alpha}\*\isqrt{\alpha}\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u11}^{\star}&\linebreak[0]\left(\isqrt{1-\alpha}\*\isqrt{\alpha}-\isqrt{1-\alpha}\*\isqrt{\alpha}\*\beta\right)\*\mathrm{u01}\*\mathrm{u11}^{\star}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}\cr }\end{dmath}
\ebm
Likewise, the reduced state of just qubit $D$ is
$\rho_{D} =\mbox{Tr}_{ABC}\rho$.\ibd{ptrace}\index{reduced state}
\bbm
\begin{verbatim}
(%i9) rho_4 : ptrace(rho,1,2,3);
\end{verbatim}
\begin{dmath}[number={\%o9}]
 \pmatrix{\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}\cr \left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}\cr }\end{dmath}
\ebm
The second method of calculating $\rho_{D}$ is as follows.
Considering the following map from
$\mathbb{C}^2\otimes\mathbb{C}^2$ to $M(\mathbb{C},2)$:
\begin{equation}\label{ket_to_mat}
    \ket{a}=\sum_{i,j=0}^1 a_{ij}\ket{ij}\quad\mapsto\quad\widehat{a}=
    \pmatrix{
      a_{00} & a_{01} \cr
      a_{10} & a_{11} \cr
    },
\end{equation}
one can show that $\rho_{D}$ is equal to $X_m^{\dagger}X_m$, with
$X_m = \widehat{\alpha}\,\widehat{u}_m\,\widehat{\beta}$.
The \pname{Maxima} function implementing the mapping (\ref{ket_to_mat}) is
\bbm
\begin{verbatim}
(%i10) ket_to_mat(iket) := matrix([iket[1,1],iket[2,1]],[iket[3,1],iket[4,1]])$
\end{verbatim}
\ebm
Then the second calculation of $\rho_D$, which we call \verb|rho_4a| is given by
the following lines.
\bbm
\begin{verbatim}
(%i11) mu : ket_to_mat(u)$
(%i12) X :  ket_to_mat(a) . mu . ket_to_mat(b);
\end{verbatim}
\begin{dmath}[number={\%o12}]
 \pmatrix{\isqrt{\alpha}\*\isqrt{\beta}\*\mathrm{u00}&\linebreak[0]\isqrt{\alpha}\*\isqrt{1-\beta}\*\mathrm{u01}\cr \isqrt{1-\alpha}\*\isqrt{\beta}\*\mathrm{u10}&\linebreak[0]\isqrt{1-\alpha}\*\isqrt{1-\beta}\*\mathrm{u11}\cr }\end{dmath}
\begin{verbatim}
(%i13) rho_4a : conjsimp( ctranspose(X) . X );
\end{verbatim}
\begin{dmath}[number={\%o13}]
 \pmatrix{\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}&\linebreak[0]\left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}^{\star}\*\mathrm{u11}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}^{\star}\*\mathrm{u01}\cr \left(1-\alpha\right)\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u10}\*\mathrm{u11}^{\star}+\alpha\*\isqrt{1-\beta}\*\isqrt{\beta}\*\mathrm{u00}\*\mathrm{u01}^{\star}&\linebreak[0]\left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}\cr }\end{dmath}
\ebm
We compare \verb|(%o9)| and  \verb|(%o13)|, to see that the two methods of calculating
the reduced state for qubit $D$ after the measurement give the same result
\bbm
\begin{verbatim}
(%i14) is ( ratsimp(rho_4a) = ratsimp(rho_4) );
\end{verbatim}
\begin{dmath}[number={\%o14}]
 \mathbf{true}\end{dmath}
\ebm
Now we compute the probability 
$p_m=\mbox{Tr}(\rho)=\mbox{Tr}(\rho_D)$
that the state is in fact projected onto $\ket{u_m}$.
\bbm
\begin{verbatim}
(%i15) P1 : conjsimp( mat_trace(rho));
\end{verbatim}
\begin{dmath}[number={\%o15}]
 \left(\left(\alpha-1\right)\*\beta-\alpha+1\right)\*\left| \mathrm{u11}\right| ^{2}+\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\left(\alpha-\alpha\*\beta\right)\*\left| \mathrm{u01}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}\end{dmath}
\ebm
Finally, we compare this to the trace computed by hand from the expression following (\ref{ket_to_mat}),
which is given by
\begin{equation}
 p_m=\sum^1_{i,j=0} {\alpha}_{i} {\beta}_{j} |\widehat{u}_{m,ij}|^2,
\end{equation}
where $\alpha_0=\alpha,\  \alpha_1=1-\alpha, \  \beta_0=\beta, \ \beta_1=1-\beta$,
\bbm
\begin{verbatim}
(%i16) av : [alpha,1-alpha]$
(%i17) bv : [beta,1-beta] $
(%i18) P2 : apply( "+", create_list( av[i] * abs(mu[i,j])^2 * bv[j], i,[1,2],j,[1,2]));
\end{verbatim}
\begin{dmath}[number={\%o18}]
 \left(1-\alpha\right)\*\left(1-\beta\right)\*\left| \mathrm{u11}\right| ^{2}+\left(1-\alpha\right)\*\beta\*\left| \mathrm{u10}\right| ^{2}+\alpha\*\left(1-\beta\right)\*\left| \mathrm{u01}\right| ^{2}+\alpha\*\beta\*\left| \mathrm{u00}\right| ^{2}\end{dmath}.
\ebm
Here we have used the
 \umaxman{apply}{\maximaapply} and 
\umaxman{create\_list}{\maximacreateUlist} functions.
Once again we compare the probabilities computed via the two methods
\bbm
\begin{verbatim}
(%i19) is (ratsimp(P1) = ratsimp(P2));
\end{verbatim}
\begin{dmath}[number={\%o19}]
 \mathbf{true}\end{dmath}
\ebm
and see that they give the same result.

Ref.~\cite{perseguers:022308} continues with a
discussion of the measurements that maximize the resulting entanglement
of $A$ and $D$. We have not yet verified this with \pname{qinf}.

\bibliography{qperc}

\htmlrule
\newpage
%\section*{Index}
\addcontentsline{toc}{section}{Index}
\printindex
\htmlrule

%\addcontentsline{toc}{section}{Index}

\end{document}

%  LocalWords:  Lapeyre Chuang Preskill Mermin subexpressions html th
%  LocalWords:  imaxima emacs frontends wxmaxima texmacs qubits qinf
%  LocalWords:  qdensity Dodier Stavros Macrakis Fateman Kets kets
%  LocalWords:  hermitian ctranspose dyad otimes tensorproduct ketz
%  LocalWords:  kronecker braz ketx brax kety multipartite eigenstate
%  LocalWords:  ket partite eigenstates proj expr tovect elementwise
%  LocalWords:  schmidt sqrt belln orthonormality genmatrix ghz ghzn
%  LocalWords:  identitymatrixp zeromatrixp orthonormal gzh gzhn
%  LocalWords:  werner Werner
